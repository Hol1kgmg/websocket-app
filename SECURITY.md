# セキュリティ設計思想

このドキュメントは、本テンプレートアプリのセキュリティ設計における意図と方針を説明します。

## 対象ユーザー

- **プライベート利用**を想定（友人・身内向け）
- URLを知っている限られた人のみがアクセス
- 不特定多数への公開は想定していない

## 設計原則

| 原則 | 説明 |
|------|------|
| **最小限の対策で最大限の効果** | プライベート利用に必要十分な対策のみ採用 |
| **運用コストを抑える** | 複雑な認証基盤やログ監視は導入しない |
| **実装コストを抑える** | シンプルな実装で保守しやすさを優先 |
| **使いやすさ優先** | 過剰なセキュリティより利便性を重視 |

## 採用した対策

| 対策 | 理由 |
|------|------|
| **Originチェック** | 許可ドメイン以外からの接続を拒否。直叩き防止として十分かつ実装が簡単 |
| **接続数制限** | ルーム全体の同時接続数を制限し、リソースを保護 |
| **アイドル検知** | 一定時間操作がない接続を切断し、枠の無駄遣いを防止 |
| **入力検証** | 許可されたメッセージ形式のみ受け付け、不正データによるクラッシュを防止 |
| **メッセージサイズ上限** | 巨大なペイロードによる負荷を防止 |
| **フロント側デバウンス** | ボタン連打による意図しない大量リクエストを抑制 |

## 意図的に採用しなかった対策

| 対策 | 採用しなかった理由 |
|------|-------------------|
| **JWT/OAuth認証** | プライベート利用には過剰。認証基盤の構築・運用コストが高い |
| **短命トークン** | Originチェックで十分。実装コストに見合わない |
| **IP単位レート制限** | 友人同士の利用では攻撃リスクが低い |
| **Cloudflare WAF** | 公開しないため入口防御の必要性が低い |
| **詳細なログ・監視** | 小規模利用では運用コストが高すぎる |
| **パスワード認証** | Originチェックで直叩きを防げるため不要 |

## 予備プラン: パスワード認証の追加

Originチェックだけでは不安な場合、パスワード認証を追加できます。

### 方式: Origin + パスワードの二重チェック

```
接続リクエスト
    │
    ▼
┌─────────────────┐
│ Origin チェック │
└────────┬────────┘
         │
    ┌────┴────┐
    │         │
 許可ドメイン  その他
    │         │
    ▼         ▼
パスワード検証  即拒否
    │
 ┌──┴──┐
 │     │
一致  不一致
 │     │
 ▼     ▼
接続OK  拒否
```

### メリット

| 観点 | 効果 |
|------|------|
| **Origin偽装対策** | 偽装されてもパスワードがなければ接続不可 |
| **URL漏洩対策** | URLを知っていてもパスワードが必要 |
| **二重防御** | 両方突破されない限り安全 |

### 実装イメージ

```typescript
// PartyKit側
onConnect(conn, ctx) {
  const origin = ctx.request.headers.get("origin");
  const allowedOrigins = ["https://your-site.pages.dev"];

  if (!allowedOrigins.includes(origin)) {
    // 許可ドメイン以外 → 即拒否
    conn.close(1008, "Forbidden");
    return;
  }

  // 許可ドメイン → パスワード検証待ち状態
  // 最初のメッセージでパスワードを検証する
}

onMessage(message, conn) {
  if (!this.authenticatedConnections.has(conn.id)) {
    const data = JSON.parse(message);
    if (data.type === "auth" && data.password === process.env.ROOM_PASSWORD) {
      this.authenticatedConnections.add(conn.id);
      conn.send(JSON.stringify({ type: "auth_success" }));
      return;
    }
    conn.close(1008, "Authentication failed");
    return;
  }

  // 認証済みの場合、通常のメッセージ処理
}
```

### フロントエンド側の対応

接続後、パスワード入力UIを表示し、認証メッセージを送信します。

```typescript
// 接続後、パスワードを送信
ws.send(JSON.stringify({ type: "auth", password: userInput }));

// 認証成功を待ってから通常操作を許可
ws.onmessage = (event) => {
  const data = JSON.parse(event.data);
  if (data.type === "auth_success") {
    // UIを操作可能にする
  }
};
```

### 採用判断の目安

| 状況 | 推奨 |
|------|------|
| 信頼できる少人数のみ利用 | Originチェックのみで十分 |
| URLが漏れる可能性がある | パスワード認証を追加 |
| より確実に部外者を排除したい | パスワード認証を追加 |

## 技術的な注意点

### Originヘッダーの偽装について

Originヘッダーはクライアント側で偽装可能です。しかし以下の理由から、プライベート利用では許容しています。

- 偽装にはある程度の技術的知識が必要
- URLを知らない第三者が偽装する動機がない
- 万が一偽装されても、接続数制限・入力検証で被害を限定できる

### 公開する場合は追加対策が必要

本アプリを不特定多数に公開する場合、以下の対策を追加することを推奨します。

| 対策 | 目的 |
|------|------|
| 短命トークン認証 | Botによる直叩きコストを上げる |
| IP単位レート制限 | 特定IPからの攻撃を緩和 |
| Cloudflare WAF | 入口での攻撃遮断 |
| 詳細ログ・監視 | 異常検知と原因究明 |

## 実装概要

```
PartyKit（サーバー側）:
├── Originチェック: 許可ドメイン以外は即拒否（close 1008）
├── 接続数制限: ルーム全体で最大10接続
├── アイドル検知: 120秒無操作で切断
├── メッセージ検証: 許可されたtypeのみ受付
└── サイズ上限: 1KB超過で切断

フロントエンド（クライアント側）:
├── heartbeat送信: 30秒間隔
└── ボタンデバウンス: 200ms
```
